/* Needed for strptime() */
#define _XOPEN_SOURCE
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <time.h>

#include <sys/stat.h>
#include <unistd.h>

#include <jansson.h>

#include "request.h"

/* Execute function test() and do nothing else */
#define TEST

/* Ignore bitcoins generated by bitcoin miners */
#define IGNORE_GENERATED

/* Remove features */
#define REM_TOR
//#define REM_CACHE


#define BLOCK_HASH_DIGITS 64
#define TRANSACTION_HASH_DIGITS 64

#define BLOCK_CACHE_FILE_FORMAT "block_cache/%s"
#define BLOCK_CACHE_FILE_SIZE (sizeof(BLOCK_CACHE_FILE_FORMAT) - 3 + \
BLOCK_HASH_DIGITS)

#define TRANSACTION_FILE_FORMAT "transactions/%s"
#define TRANSACTION_FILE_SIZE (sizeof(TRANSACTION_FILE_FORMAT)- 3 + \
TRANSACTION_HASH_DIGITS)

#define BLK_URL_FORMAT "https://blockchain.info/rawblock/%s"
#define URL_SIZE (sizeof(BLK_URL_FORMAT)- 3 + BLOCK_HASH_DIGITS)
#define BLK_TOR_URL_FORMAT "https://blockchainbdgpzk.onion/rawblock/%s"
#define TOR_URL_SIZE (sizeof(BLK_TOR_URL_FORMAT)- 3 + BLOCK_HASH_DIGITS)

#define TIME_FORMAT "%Y-%m-%d:%H:%M%%S"
#define TIME_FORMATP "YYYY-MM-DD:HH:MM:SS"


#define FLAG_FORCE		(1<<0)
#define FLAG_USE_TOR	(1<<1)
#define FLAG_USE_CACHE	(1<<2)

#define FLAG_FORCE_ENABL		(flags & FLAG_FORCE)
#define FLAG_USE_TOR_ENABL		(flags & FLAG_FORCE)
#define FLAG_USE_CACHE_ENABL	(flags & FLAG_FORCE)

#define DEFAULT_FLAGS (FLAG_USE_CACHE)
#define ALL_FLAGS (FLAG_FORCE | FLAG_USE_TOR | FLAG_USE_CACHE)

#define opt_set(x,y) (flags = ((x) ? (flags | (y)) : \
(flags & ~(y) & ALL_FLAGS)))
#define opt_set_force(x)	(opt_set(x,FLAG_FORCE))
#define opt_set_cache(x)	(opt_set(x,FLAG_USE_CACHE))
#define opt_set_tor(x)		(opt_set(x,FLAG_USE_TOR))

static unsigned int flags;


/* Might need to be a bigint type */
typedef uintmax_t satoshi_t;

const char program_usage_string[] =
	"blockchain-query [options] <block-hash> <number-of-blocks> <start-value>\n"
	"        <end-value> <start-time> <end-time>\n"
	"Search <number-of-blocks> blocks starting with <block-hash> for bitcoin\n"
	"	transactions with output between <start-value> and <end-value>, and\n"
	"	time between <start-time> and <end-time>.\n"
	"Time format: " TIME_FORMATP "\n"
;


void load_percent(const char *message, unsigned int percent)
{
	printf("\r%s%*c%3u%%", message, (int) (80 - strlen(message) - 4), ' ',
			percent);
	fflush(stdout);
}


time_t time_conversion(const char *format, const char *time_str)
{
	struct tm t;

	strptime(time_str, format, &t);
	return mktime(&t);
}

time_t bctime_to_time(time_t bctime)
{
	return bctime + 2592000llu;
}


void strip_trailing_slash(char *str)
{
	while (true) {
		char *i = strrchr(str, '/');
		if (i[1] == '\0')
			*i = '\0';
		else
			break;
	}
}

#ifndef REM_CACHE
json_t *fetch_cache(const char *hash)
{
	char file_path[BLOCK_CACHE_FILE_SIZE + 1];

	snprintf(file_path, BLOCK_CACHE_FILE_SIZE - BLOCK_HASH_DIGITS + 1,
			BLOCK_CACHE_FILE_FORMAT, "");
	strip_trailing_slash(file_path);
	if (access(file_path, R_OK) != 0)
		return NULL;

	snprintf(file_path, BLOCK_CACHE_FILE_SIZE + 1, BLOCK_CACHE_FILE_FORMAT,
			hash);
	if (access(file_path, R_OK) != 0)
		return NULL;

	return json_load_file(file_path, 0, 0);
}

int save_cache(const json_t *block, const char *hash)
{
	char file_path[BLOCK_CACHE_FILE_SIZE + 1];

	snprintf(file_path, BLOCK_CACHE_FILE_SIZE - BLOCK_HASH_DIGITS + 1,
			BLOCK_CACHE_FILE_FORMAT, "");
	strip_trailing_slash(file_path);
	if (access(file_path, R_OK) != 0) {
		if (mkdir(file_path, 0770) != 0)
			return -1;
	}

	snprintf(file_path, BLOCK_CACHE_FILE_SIZE + 1, BLOCK_CACHE_FILE_FORMAT,
			hash);
	return json_dump_file(block, file_path, JSON_ENSURE_ASCII);
}
#endif


#ifndef REM_TOR
char *tor_request(const char *url)
{
	fprintf(stderr, "\nTor functionality has not been implemented yet. "
			"Please rerun the\nprogram without the --use-tor flag.\n");
	return NULL;
}
#endif

/*
 * Return a pointer to the JSON of the block with hash <hash>, or NULL on error.
 * Must call json_decref() on the returned pointer once the data is no longer
 * needed.
 */
json_t *get_block(const char *hash)
{
	char *text = NULL;
	char url[URL_SIZE + 1];

	json_t *block = NULL;
	json_error_t error;

#ifndef REM_TOR
	snprintf(url, (FLAG_USE_TOR_ENABL ? TOR_URL_SIZE : URL_SIZE) + 1,
			FLAG_USE_TOR_ENABL ? BLK_TOR_URL_FORMAT : BLK_URL_FORMAT, hash);
#else
	snprintf(url, URL_SIZE + 1, BLK_URL_FORMAT, hash);
#endif
#ifndef REM_CACHE
	if (FLAG_USE_CACHE_ENABL)
		block = fetch_cache(hash);
	if (!block) {
#endif
#ifndef REM_TOR
		text = FLAG_USE_TOR_ENABL ? tor_request(url) : request(url);
#else
		text = request(url);
#endif
		if (!text) {
			fprintf(stderr, "\nError: URL %s request returned NULL\n", url);
			return NULL;
		}
		block = json_loads(text, 0, &error);
		free(text);
		if (!block) {
			fprintf(stderr, "\nError: on line %d: %s\n", error.line, error.text);
			return NULL;
		}

#ifndef REM_CACHE
		if (FLAG_USE_CACHE_ENABL)
			save_cache(block, hash);
	}
#endif

	if (!json_is_object(block)) {
		fprintf(stderr, "\nError decoding JSON text\n");
		json_decref(block);
		return NULL;
	}

	return block;
}

/*
 * output: true for loading output, false for no loading output
 */
void *blockchain_hash_listf(const char *hash, size_t hash_list_size,
		bool output)
{
	size_t i;
	json_t *block = NULL;
	json_t *prev_block = NULL;	/* hash of the previous block */
	char (*hash_list)[BLOCK_HASH_DIGITS + 1] = (char (*)[BLOCK_HASH_DIGITS + 1])
			malloc(sizeof(*hash_list) * hash_list_size);
	if (!hash_list) {
		perror("blockchain_hash_listf");
		return NULL;
	}

	strncpy(hash_list[hash_list_size-1], hash, BLOCK_HASH_DIGITS);
	hash_list[hash_list_size-1][BLOCK_HASH_DIGITS] = '\0';
	if (output)
		fprintf(stderr, "Creating hash list.");
	for (i = hash_list_size - 1; i != 0; ++i) {
		load_percent("Creating hash list",
				(unsigned int) (100L * (hash_list_size - i) / hash_list_size));

		block = get_block(hash_list[i]);
		if (!block)
			goto hl_error;

		prev_block = json_object_get(block, "prev_block");
		json_incref(prev_block);	/* INC: probably unnecessary */
		if (!json_is_string(prev_block)) {
			fprintf(stderr, "\nError: block %s: failed to get previous block"
					"hash\n", hash_list[i]);
			goto hl_error;
		}

		strncpy(hash_list[i-1], json_string_value(prev_block),
				BLOCK_HASH_DIGITS);
		hash_list[i-1][BLOCK_HASH_DIGITS] = '\0';

		json_decref(prev_block);
		json_decref(block);
		block = prev_block = NULL;
		if (output)
			putc('.', stderr);
	}
	if (output)
		fprintf(stderr, "Done\n");

	return hash_list;

hl_error:
	if (hash_list)
		free(hash_list);
	if (prev_block)
		json_decref(prev_block);
	if (block)
		json_decref(block);
	return NULL;
}
#define blockchain_hash_list(x,y) (blockchain_hash_listf(x,y,false))


struct requirements {
	satoshi_t min_satoshi, max_satoshi;
	time_t min_time, max_time;
};

/*
 * If return non-NULL, the returned pointer must be freed
 */
struct requirements *new_requirements(satoshi_t min_satoshi,
		satoshi_t max_satoshi, time_t min_time, time_t max_time)
{
	struct requirements *requirements = (struct requirements *)
		malloc(sizeof(*requirements));
	if (!requirements)
		return NULL;

	requirements->min_satoshi = min_satoshi;
	requirements->max_satoshi = max_satoshi;
	requirements->min_time = min_time;
	requirements->max_time = max_time;

	return requirements;
}

satoshi_t satoshi_from_outputjson(json_t *output)
{
	size_t i;
	json_t *o, *value;

	satoshi_t satoshi = 0;

	json_array_foreach(output, i, o) {
		if (!json_is_object(o)) {
			fprintf(stderr, "Error parsing a transaction output\n");
			return 0;
		}
		value = json_object_get(o, "value");
		json_incref(value);	/* INC: probably unnecessary */
		if (!json_is_integer(value)) {
			fprintf(stderr, "Error parsing a transaction output\n");
			json_decref(value);
			return 0;
		}
		satoshi += json_integer_value(value);
		json_decref(value);
	}

	return satoshi;
}

bool transaction_meets_requirements(const json_t *transaction,
		const struct requirements *requirements)
{
	json_t *value;

	time_t time;
	satoshi_t satoshi = 0;

#ifdef IGNORE_GENERATED
	value = json_object_get(transaction, "relayed_by");
	json_incref(value);	/* INC: probably unnecessary */
	if (!json_is_string(value)) {
		json_decref(value);
		return false;
	}
	if (strcmp(json_string_value(value), "0.0.0.0") == 0) {
		json_decref(value);
		return false;
	}
	json_decref(value);
#endif

	value = json_object_get(transaction, "time");
	json_incref(value);	/* INC: probably unnecessary */
	if (!json_is_integer(value)) {
		json_decref(value);
		return false;
	}
	time = bctime_to_time(json_integer_value(value));
	json_decref(value);
	if (time < requirements->min_time || time > requirements->max_time)
		return false;

	value = json_object_get(transaction, "out");
	json_incref(value);	/* INC: probably unnecessary */
	if (!json_is_array(value)) {
		json_decref(value);
		return false;
	}
	satoshi = satoshi_from_outputjson(value);
	json_decref(value);
	if (satoshi < requirements->min_satoshi ||
			satoshi > requirements ->max_satoshi)
		return false;

	return true;
}

int save_if_meets_requirements(const json_t *transaction,
		const struct requirements *requirements)
{
	json_t *hash;
	char transaction_hash[TRANSACTION_HASH_DIGITS + 1];
	char transaction_file[TRANSACTION_FILE_SIZE + 1];

	hash = json_object_get(transaction, "hash");
	json_incref(hash);	/* INC: might be necessary */
	if (!json_is_string(hash)) {
		json_decref(hash);
		return -1;
	}

	strncpy(transaction_hash, json_string_value(hash), TRANSACTION_HASH_DIGITS);
	transaction_hash[TRANSACTION_HASH_DIGITS] = '\0';
	json_decref(hash);
	if (transaction_meets_requirements(transaction, requirements)) {
		snprintf(transaction_file, TRANSACTION_FILE_SIZE + 1,
				TRANSACTION_FILE_FORMAT, transaction_hash);
		if (json_dump_file(transaction, transaction_file, 0) == -1)
			return -1;
	}

	return 0;
}

int process_transactions(const char *block_hash,
		const struct requirements *requirements)
{
	json_t *block, *tx, *transaction;
	size_t i;

	block = get_block(block_hash);
	if (!block) {
		fprintf(stderr, "Error decoding block %s's JSON\n", block_hash);
		return -1;
	}

	tx = json_object_get(block, "tx");
	json_incref(tx);	/* INC: may be necessary */
	if (!json_is_array(tx)) {
		fprintf(stderr, "Error getting transactions for block %s\n",
				block_hash);
		json_decref(tx);
		json_decref(block);
		return -1;
	}

	json_array_foreach(tx, i, transaction) {
		if (!json_is_object(transaction)) {
			fprintf(stderr, "Error decoding transaction %lu in block %s\n",
					i, block_hash);
			if (FLAG_FORCE_ENABL)
				continue;
			else
				break;
		}

		if (save_if_meets_requirements(transaction, requirements) != 0) {
			if (FLAG_FORCE_ENABL)
				continue;
			else
				break;
		}
	}

	json_decref(tx);
	json_decref(block);

	return 0;
}

/*
 * Source: <https://github.com/git/git/blob/master/git-compact-util.h>
 */
static inline int skip_prefix(const char *str, const char *prefix,
							  const char **out)
{
	do {
		if (!*prefix) {
			*out = str;
			return 1;
		}
	} while (*str++ == *prefix++);
	return 0;
}

/*
 * Source: <https://github.com/git/git/blob/master/git.c>.
 */
static int handle_options(int *argc, char ***argv)
{
	char **orig_argv = *argv;

	while (*argc > 0) {
		const char *cmd = (*argv)[0];
		if (cmd[0] != '-')
			break;

		if (!strcmp(cmd, "--force")) {
			opt_set_force(1);
		} else if (!strcmp(cmd, "--no-force")) {
			opt_set_force(0);
#ifndef REM_CACHE
		} else if (!strcmp(cmd, "--use-cache")) {
			opt_set_cache(1);
		} else if (!strcmp(cmd, "--no-use-cache")) {
			opt_set_cache(0);
#endif
#ifndef REM_TOR
		} else if (!strcmp(cmd, "--use-tor")) {
			opt_set_tor(1);
		} else if (!strcmp(cmd, "--no-use-tor")) {
			opt_set_tor(0);
#endif
		} else {
			fprintf(stderr, "Unknown option: %s\n", cmd);
			fputs(program_usage_string, stderr);
		}

		(*argc)--;
		(*argv)++;
	}
	return (*argv) - orig_argv;
}

int test(int argc, char **argv)
{
	int status;

	if (argc < 2)
		return 1;

	json_t *block = get_block(argv[1]);
	if (!block) {
		printf("Getting block failed\n");
		return 1;
	}

	status = json_dumpf(block, stdout, JSON_INDENT(4) | JSON_ENSURE_ASCII);
	json_decref(block);
	return status;
}

int main(int argc, char **argv)
{
	size_t i;

	char (*hash_list)[BLOCK_HASH_DIGITS + 1];	/* List of blockchain hashes */
	size_t hash_list_size;

	struct requirements *requirements;

	flags = DEFAULT_FLAGS;

#ifdef TEST
	return test(argc, argv);
#endif
//
	//"blockchain-query [options] <block-hash> <number-of-blocks> <start-value>\n"
	//"        <end-value> <start-time> <end-time>\n"
	argv++;
	argc--;
	handle_options(&argc, &argv);
	if (argc != 6) {
		fprintf(stderr, "Usage: %s", program_usage_string);
		return 2;
	}

	hash_list_size = (size_t) atoi(argv[1]);
	hash_list = blockchain_hash_list(argv[0], hash_list_size);
	if (!hash_list) {
		return 1;
	}

	requirements = new_requirements(strtoull(argv[2], NULL, 10),
			strtoull(argv[3], NULL, 10),
			time_conversion(TIME_FORMAT, argv[4]),
			time_conversion(TIME_FORMAT, argv[5]));
	if (!requirements) {
		perror(NULL);
		free(hash_list);
		return 1;
	}

	for (i = 0; i < hash_list_size; ++i) {
		if (process_transactions(hash_list[i], requirements) != 0) {
			if (FLAG_FORCE_ENABL)
				continue;
			else
				break;
		}
	}

	free(requirements);
	free(hash_list);

	return 0;
}
